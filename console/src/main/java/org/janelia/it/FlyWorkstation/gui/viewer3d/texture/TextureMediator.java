package org.janelia.it.FlyWorkstation.gui.viewer3d.texture;

import org.janelia.it.FlyWorkstation.gui.viewer3d.VolumeDataAcceptor;

import javax.media.opengl.GL2;
import java.nio.IntBuffer;

/**
 * Created with IntelliJ IDEA.
 * User: fosterl
 * Date: 1/17/13
 * Time: 2:48 PM
 *
 * This handles interfacing with OpenGL / JOGL for matters regarding textures.  One such mediator represents information
 * regarding a single texture.
 */
public class TextureMediator {
    private static int s_textureCount = 0;  // Optional: an assumed sequence of textures is made.

    private int textureName;
    private int textureSymbolicId; // This is an ID like GL.GL_TEXTURE0.
    private int textureOffset; // This will be 0, 1, ...

    private IntBuffer data;
    private int[] voxels;

    /**
     * Dimensions of rectangular volume, from centers of corner voxels, in world units.
     */
    private double[] volumeMicrometers = {1.0, 2.0, 3.0};

    /**
     * Size of a single voxel, in world units.
     */
    private double[] voxelMicrometers = {1.0, 1.0, 1.0};

    private static final int INTERPOLATION_METHOD =
            GL2.GL_LINEAR; // blending across voxel edges
    // GL2.GL_NEAREST; // discrete cube shaped voxels

    // Color space is linear for most microscopy LSM, TIFF and V3DRAW files
    private VolumeDataAcceptor.TextureColorSpace colorSpace = VolumeDataAcceptor.TextureColorSpace.COLOR_SPACE_LINEAR;

    public static int[] genTextureIds( GL2 gl, int count ) {
        int[] rtnVal = new int[ count ];
        gl.glGenTextures( count, rtnVal, 0 );
        return rtnVal;
    }

    public TextureMediator() {
        // No initialization.
    }

    public TextureMediator( int textureId ) {
        init( textureId, s_textureCount ++ );
    }

    /**
     * Initialize a mediator.  Assumptions that can be made about various identifiers will be made here.
     *
     * @param textureId as generated by @See #genTextureIds
     * @param offset 0, 1, ...
     */
    public void init( int textureId, int offset ) {
        this.textureName = textureId;
        this.textureOffset = offset;
        textureSymbolicId = GL2.GL_TEXTURE0 + offset;
    }

    public void uploadTexture( GL2 gl ) {

        if ( data != null ) {
            gl.glActiveTexture( textureSymbolicId );
            gl.glEnable( GL2.GL_TEXTURE_3D );

            gl.glBindTexture(GL2.GL_TEXTURE_3D, textureName );
            gl.glTexEnvi(GL2.GL_TEXTURE_ENV, GL2.GL_TEXTURE_ENV_MODE, GL2.GL_REPLACE);
            int internalFormat = GL2.GL_RGBA8;
            if (colorSpace == VolumeDataAcceptor.TextureColorSpace.COLOR_SPACE_SRGB)
                internalFormat = GL2.GL_SRGB8_ALPHA8;

            gl.glTexImage3D(GL2.GL_TEXTURE_3D,
                    0, // mipmap level
                    internalFormat, // bytes per pixel, plus somehow srgb info
                    voxels[ 0 ], // width
                    voxels[ 1 ], // height
                    voxels[ 2 ], // depth
                    0, // border
                    GL2.GL_BGRA, // voxel component order
                    GL2.GL_UNSIGNED_INT_8_8_8_8_REV, // voxel component type
                    data.rewind()
            );
        }
    }

    public IntBuffer getData() {
        return data;
    }

    public void setData(IntBuffer data) {
        this.data = data;
    }

    public int[] getVoxels() {
        return voxels;
    }

    public void setVoxels(int[] voxels) {
        this.voxels = voxels;
    }

    public VolumeDataAcceptor.TextureColorSpace getColorSpace() {
        return colorSpace;
    }

    public void setColorSpace( VolumeDataAcceptor.TextureColorSpace colorSpace ) {
        this.colorSpace = colorSpace;
    }

    public double[] textureCoordinateFromXyz( double[] xyz ) {
        double[] tc = {xyz[0], xyz[1], xyz[2]}; // micrometers, origin at center
        for (int i =0; i < 3; ++i) {
            // Move origin to upper left corner
            tc[i] += volumeMicrometers[i] / 2.0; // micrometers, origin at corner
            // Rescale from micrometers to voxels
            tc[i] /= voxelMicrometers[i]; // voxels, origin at corner
            // Rescale from voxels to texture units (range 0-1)
            tc[i] /= voxels[i]; // texture units
        }

        return tc;
    }

    public void setTextureCoordinates( GL2 gl, double tX, double tY, double tZ ) {
        gl.glMultiTexCoord3d(textureSymbolicId, tX, tY, tZ);
    }

    public double[] getVolumeMicrometers() {
        return volumeMicrometers;
    }

    public void setVolumeMicrometers(double[] volumeMicrometers) {
        this.volumeMicrometers = volumeMicrometers;
    }

    public double[] getVoxelMicrometers() {
        return voxelMicrometers;
    }

    public void setVoxelMicrometers(double[] voxelMicrometers) {
        this.voxelMicrometers = voxelMicrometers;
    }

    public void setupTexture( GL2 gl ) {
        gl.glActiveTexture( textureSymbolicId );
        gl.glBindTexture( GL2.GL_TEXTURE_3D, textureName );
        gl.glTexParameteri(GL2.GL_TEXTURE_3D, GL2.GL_TEXTURE_MIN_FILTER, INTERPOLATION_METHOD);
        gl.glTexParameteri(GL2.GL_TEXTURE_3D, GL2.GL_TEXTURE_MAG_FILTER, INTERPOLATION_METHOD);
        gl.glTexParameteri(GL2.GL_TEXTURE_3D, GL2.GL_TEXTURE_WRAP_R, GL2.GL_CLAMP_TO_BORDER);
        gl.glTexParameteri(GL2.GL_TEXTURE_3D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_CLAMP_TO_BORDER);
        gl.glTexParameteri(GL2.GL_TEXTURE_3D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_CLAMP_TO_BORDER);
    }

}
